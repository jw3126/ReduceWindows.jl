var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ReduceWindows","category":"page"},{"location":"#ReduceWindows","page":"Home","title":"ReduceWindows","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ReduceWindows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ReduceWindows]","category":"page"},{"location":"#ReduceWindows.reduce_window-Union{Tuple{F}, Tuple{F, AbstractArray, Any}, Tuple{F, AbstractArray, Any, Any}} where F","page":"Home","title":"ReduceWindows.reduce_window","text":"reduce_window(f, arr, window)\n\nMove a sliding window over the arr and apply reduce(f, view(arr, shifted window...)) For instance window = (-1:2, 3:4) will produce an output matrix with entries:\n\nout[i,j] = reduce(f, arr[(i-1):(i+2), (j+3):(j+4)])\n\nThis is equation is true semantically, but in implementation much less work will be done. Time complexity is O(log(k) * n) where \n\nn is the size of the array: n = length(arr)\nk is the size of the window: k = prod(length, window)\n\nNote reduce_window assumes, that f is associative and commutative.\n\n\n\n\n\n","category":"method"}]
}
